----- Notes on the problem:

Search for the Adaptor pattern and it's variations

Your solution should demonstrate appropriate separation of responsibilities and code isolation.

the point is to create an abstraction that makes bank1 and bank2 look the same,
 not to create an adaptor that makes, for instance, bank1 look like bank2.

 unit tests

 patterns, layering, code isolation, separation of concerns, testability etc.

----- Notes on bank 1:

public Double getAccountBalance(long accountId) {
        return 215.5d;
    }
public String getAccountCurrency(long accountId) {
    return "USD";
}

public static int TYPE_CREDIT = 1;
public static int TYPE_DEBIT = 2;

private double amount;
private int type;
private String text;

new Bank1Transaction(100d, Bank1Transaction.TYPE_CREDIT, "Check deposit")

----- Notes on bank 2:

public Bank2AccountBalance getBalance(long accountNum) {
    return new Bank2AccountBalance(512.5d, "USD");

new Bank2AccountTransaction(125d, Bank2AccountTransaction.TRANSACTION_TYPES.DEBIT, "Amazon.com"),

public static enum TRANSACTION_TYPES {
    DEBIT, CREDIT
}

private double amount;
private TRANSACTION_TYPES type;
private String text;

public double getAmount() {
    return amount;
}

public TRANSACTION_TYPES getType() {
    return type;
}

public String getText() {
    return text;
}
